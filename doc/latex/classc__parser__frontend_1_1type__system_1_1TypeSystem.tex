\hypertarget{classc__parser__frontend_1_1type__system_1_1TypeSystem}{}\doxysection{c\+\_\+parser\+\_\+frontend\+::type\+\_\+system\+::Type\+System类 参考}
\label{classc__parser__frontend_1_1type__system_1_1TypeSystem}\index{c\_parser\_frontend::type\_system::TypeSystem@{c\_parser\_frontend::type\_system::TypeSystem}}


类型系统  




{\ttfamily \#include $<$type\+\_\+system.\+h$>$}

\doxysubsection*{类}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_1_1TypeData}{Type\+Data}}
\begin{DoxyCompactList}\small\item\em 存储某个类型名下的不同类型链信息 \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public 类型}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_a1b3ab58d873399194caaf2ebf468e6fb}{Type\+Node\+Container\+Iter}} = Type\+Node\+Container\+Type\+::const\+\_\+iterator
\begin{DoxyCompactList}\small\item\em 指向类型名和对应类型链的迭代器 \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public 成员函数}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class Type\+Name $>$ }\\std\+::pair$<$ Type\+Node\+Container\+Type\+::const\+\_\+iterator, \mbox{\hyperlink{namespacec__parser__frontend_1_1type__system_a53035d13ed98c1c9c754e011d3c3320d}{Add\+Type\+Result}} $>$ \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_af8ea1dc56730fbe42ad70ff578ae532b}{Define\+Type}} (Type\+Name \&\&type\+\_\+name, const std\+::shared\+\_\+ptr$<$ const \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeInterface}{Type\+Interface}} $>$ \&type\+\_\+pointer)
\begin{DoxyCompactList}\small\item\em 向类型系统中添加类型 \end{DoxyCompactList}\item 
std\+::pair$<$ Type\+Node\+Container\+Type\+::const\+\_\+iterator, \mbox{\hyperlink{namespacec__parser__frontend_1_1type__system_a53035d13ed98c1c9c754e011d3c3320d}{Add\+Type\+Result}} $>$ \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_a55119a508fa7ca1257475ec7795315c8}{Announce\+Function\+Type}} (const std\+::shared\+\_\+ptr$<$ const \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1FunctionType}{Function\+Type}} $>$ \&function\+\_\+type)
\begin{DoxyCompactList}\small\item\em 声明函数类型 \end{DoxyCompactList}\item 
std\+::pair$<$ std\+::shared\+\_\+ptr$<$ const \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeInterface}{Type\+Interface}} $>$, \mbox{\hyperlink{namespacec__parser__frontend_1_1type__system_a8beb6f70423e49b45609ea37c23839d9}{Get\+Type\+Result}} $>$ \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_aced9a8ca3d94b1528984e203601df3ff}{Get\+Type}} (const std\+::string \&type\+\_\+name, \mbox{\hyperlink{namespacec__parser__frontend_1_1type__system_a7ada2ff0eba2205e6a1c0c5afa2d5bd7}{Struct\+Or\+Basic\+Type}} type\+\_\+prefer)
\begin{DoxyCompactList}\small\item\em 根据类型名和类型的选择倾向获取类型 \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private 类型}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_a8031776633f7d935b30ff78a1cbf9e7f}{Type\+Node\+Container\+Type}} = std\+::unordered\+\_\+map$<$ std\+::string, \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_1_1TypeData}{Type\+Data}} $>$
\begin{DoxyCompactList}\small\item\em 存储类型名到类型链容器的映射 \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private 成员函数}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_a8031776633f7d935b30ff78a1cbf9e7f}{Type\+Node\+Container\+Type}} \& \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_a758de256c4f407f85ef4a1113075b2a1}{Get\+Type\+Name\+To\+Node}} ()
\begin{DoxyCompactList}\small\item\em 获取全部类型名到类型链的映射 \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Private 属性}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_a8031776633f7d935b30ff78a1cbf9e7f}{Type\+Node\+Container\+Type}} \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_a4472c8e3a047310c47754dcf0be70f80}{type\+\_\+name\+\_\+to\+\_\+node\+\_\+}}
\begin{DoxyCompactList}\small\item\em 保存类型名到类型链的映射 \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{详细描述}
类型系统 

1.类型系统存储自定义类型名到类型名对应的类型链的映射 2.允许一个类型名绑定多个类型，这种情况下如果根据类型名获取类型链时不指定具体 类型则无法获取 3.根据\+Type\+System\+::\+Type\+Data\+::\+Is\+Same\+Kind判断两个类型是否属于同一大类， Struct\+Or\+Basic\+Type中除了\+Basic\+Type和\+Pointer\+Type属于同一大类以外，其余类型 各自成一大类 4.仅当待添加的类型与已有类型均不属于同一大类时可以添加（除相同签名函数类型） 5.所有类型均有全局定义域 

在文件 type\+\_\+system.\+h 第 1096 行定义.



\doxysubsection{成员类型定义说明}
\mbox{\Hypertarget{classc__parser__frontend_1_1type__system_1_1TypeSystem_a1b3ab58d873399194caaf2ebf468e6fb}\label{classc__parser__frontend_1_1type__system_1_1TypeSystem_a1b3ab58d873399194caaf2ebf468e6fb}} 
\index{c\_parser\_frontend::type\_system::TypeSystem@{c\_parser\_frontend::type\_system::TypeSystem}!TypeNodeContainerIter@{TypeNodeContainerIter}}
\index{TypeNodeContainerIter@{TypeNodeContainerIter}!c\_parser\_frontend::type\_system::TypeSystem@{c\_parser\_frontend::type\_system::TypeSystem}}
\doxysubsubsection{\texorpdfstring{TypeNodeContainerIter}{TypeNodeContainerIter}}
{\footnotesize\ttfamily using \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_a1b3ab58d873399194caaf2ebf468e6fb}{c\+\_\+parser\+\_\+frontend\+::type\+\_\+system\+::\+Type\+System\+::\+Type\+Node\+Container\+Iter}} =  Type\+Node\+Container\+Type\+::const\+\_\+iterator}



指向类型名和对应类型链的迭代器 



在文件 type\+\_\+system.\+h 第 1176 行定义.

\mbox{\Hypertarget{classc__parser__frontend_1_1type__system_1_1TypeSystem_a8031776633f7d935b30ff78a1cbf9e7f}\label{classc__parser__frontend_1_1type__system_1_1TypeSystem_a8031776633f7d935b30ff78a1cbf9e7f}} 
\index{c\_parser\_frontend::type\_system::TypeSystem@{c\_parser\_frontend::type\_system::TypeSystem}!TypeNodeContainerType@{TypeNodeContainerType}}
\index{TypeNodeContainerType@{TypeNodeContainerType}!c\_parser\_frontend::type\_system::TypeSystem@{c\_parser\_frontend::type\_system::TypeSystem}}
\doxysubsubsection{\texorpdfstring{TypeNodeContainerType}{TypeNodeContainerType}}
{\footnotesize\ttfamily using \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_a8031776633f7d935b30ff78a1cbf9e7f}{c\+\_\+parser\+\_\+frontend\+::type\+\_\+system\+::\+Type\+System\+::\+Type\+Node\+Container\+Type}} =  std\+::unordered\+\_\+map$<$std\+::string, \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_1_1TypeData}{Type\+Data}}$>$\hspace{0.3cm}{\ttfamily [private]}}



存储类型名到类型链容器的映射 



在文件 type\+\_\+system.\+h 第 1172 行定义.



\doxysubsection{成员函数说明}
\mbox{\Hypertarget{classc__parser__frontend_1_1type__system_1_1TypeSystem_a55119a508fa7ca1257475ec7795315c8}\label{classc__parser__frontend_1_1type__system_1_1TypeSystem_a55119a508fa7ca1257475ec7795315c8}} 
\index{c\_parser\_frontend::type\_system::TypeSystem@{c\_parser\_frontend::type\_system::TypeSystem}!AnnounceFunctionType@{AnnounceFunctionType}}
\index{AnnounceFunctionType@{AnnounceFunctionType}!c\_parser\_frontend::type\_system::TypeSystem@{c\_parser\_frontend::type\_system::TypeSystem}}
\doxysubsubsection{\texorpdfstring{AnnounceFunctionType()}{AnnounceFunctionType()}}
{\footnotesize\ttfamily std\+::pair$<$Type\+Node\+Container\+Type\+::const\+\_\+iterator, \mbox{\hyperlink{namespacec__parser__frontend_1_1type__system_a53035d13ed98c1c9c754e011d3c3320d}{Add\+Type\+Result}}$>$ c\+\_\+parser\+\_\+frontend\+::type\+\_\+system\+::\+Type\+System\+::\+Announce\+Function\+Type (\begin{DoxyParamCaption}\item[{const std\+::shared\+\_\+ptr$<$ const \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1FunctionType}{Function\+Type}} $>$ \&}]{function\+\_\+type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



声明函数类型 


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em function\+\_\+type} & ：函数类型链头结点 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
前半部分为指向插入位置的迭代器，后半部分为添加结果 
\end{DoxyReturn}


在文件 type\+\_\+system.\+h 第 1191 行定义.



引用了 Define\+Type() , 以及 c\+\_\+parser\+\_\+frontend\+::type\+\_\+system\+::k\+Function.



被这些函数引用 c\+\_\+parser\+\_\+frontend\+::\+C\+Parser\+Frontend\+::\+Announce\+Function() , 以及 c\+\_\+parser\+\_\+frontend\+::\+C\+Parser\+Frontend\+::\+Finish\+Function\+Construct().

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classc__parser__frontend_1_1type__system_1_1TypeSystem_a55119a508fa7ca1257475ec7795315c8_cgraph}
\end{center}
\end{figure}
这是这个函数的调用关系图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classc__parser__frontend_1_1type__system_1_1TypeSystem_a55119a508fa7ca1257475ec7795315c8_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classc__parser__frontend_1_1type__system_1_1TypeSystem_af8ea1dc56730fbe42ad70ff578ae532b}\label{classc__parser__frontend_1_1type__system_1_1TypeSystem_af8ea1dc56730fbe42ad70ff578ae532b}} 
\index{c\_parser\_frontend::type\_system::TypeSystem@{c\_parser\_frontend::type\_system::TypeSystem}!DefineType@{DefineType}}
\index{DefineType@{DefineType}!c\_parser\_frontend::type\_system::TypeSystem@{c\_parser\_frontend::type\_system::TypeSystem}}
\doxysubsubsection{\texorpdfstring{DefineType()}{DefineType()}}
{\footnotesize\ttfamily template$<$class Type\+Name $>$ \\
std\+::pair$<$ Type\+System\+::\+Type\+Node\+Container\+Type\+::const\+\_\+iterator, \mbox{\hyperlink{namespacec__parser__frontend_1_1type__system_a53035d13ed98c1c9c754e011d3c3320d}{Add\+Type\+Result}} $>$ c\+\_\+parser\+\_\+frontend\+::type\+\_\+system\+::\+Type\+System\+::\+Define\+Type (\begin{DoxyParamCaption}\item[{Type\+Name \&\&}]{type\+\_\+name,  }\item[{const std\+::shared\+\_\+ptr$<$ const \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeInterface}{Type\+Interface}} $>$ \&}]{type\+\_\+pointer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



向类型系统中添加类型 


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em type\+\_\+name} & ：类型名 \\
\hline
\mbox{\texttt{ in}}  & {\em type\+\_\+pointer} & ：类型链头结点指针 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
前半部分为指向插入位置的迭代器，后半部分为添加结果 
\end{DoxyReturn}
\begin{DoxyNote}{注解}
添加类型的规则见\+Type\+Data\+::\+Add\+Type的注释 \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_1_1TypeData_a58716d70558dd04ec69f7c7fab5fb398}{Type\+Data\+::\+Add\+Type}} 
\end{DoxyNote}


在文件 type\+\_\+system.\+h 第 1216 行定义.



引用了 Get\+Type\+Name\+To\+Node(), c\+\_\+parser\+\_\+frontend\+::type\+\_\+system\+::k\+End , 以及 c\+\_\+parser\+\_\+frontend\+::type\+\_\+system\+::k\+Not\+Specified.



被这些函数引用 Announce\+Function\+Type() , 以及 c\+\_\+parser\+\_\+frontend\+::\+C\+Parser\+Frontend\+::\+Define\+Type().

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classc__parser__frontend_1_1type__system_1_1TypeSystem_af8ea1dc56730fbe42ad70ff578ae532b_cgraph}
\end{center}
\end{figure}
这是这个函数的调用关系图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classc__parser__frontend_1_1type__system_1_1TypeSystem_af8ea1dc56730fbe42ad70ff578ae532b_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classc__parser__frontend_1_1type__system_1_1TypeSystem_aced9a8ca3d94b1528984e203601df3ff}\label{classc__parser__frontend_1_1type__system_1_1TypeSystem_aced9a8ca3d94b1528984e203601df3ff}} 
\index{c\_parser\_frontend::type\_system::TypeSystem@{c\_parser\_frontend::type\_system::TypeSystem}!GetType@{GetType}}
\index{GetType@{GetType}!c\_parser\_frontend::type\_system::TypeSystem@{c\_parser\_frontend::type\_system::TypeSystem}}
\doxysubsubsection{\texorpdfstring{GetType()}{GetType()}}
{\footnotesize\ttfamily std\+::pair$<$ std\+::shared\+\_\+ptr$<$ const \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeInterface}{Type\+Interface}} $>$, \mbox{\hyperlink{namespacec__parser__frontend_1_1type__system_a8beb6f70423e49b45609ea37c23839d9}{Get\+Type\+Result}} $>$ c\+\_\+parser\+\_\+frontend\+::type\+\_\+system\+::\+Type\+System\+::\+Get\+Type (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{type\+\_\+name,  }\item[{\mbox{\hyperlink{namespacec__parser__frontend_1_1type__system_a7ada2ff0eba2205e6a1c0c5afa2d5bd7}{Struct\+Or\+Basic\+Type}}}]{type\+\_\+prefer }\end{DoxyParamCaption})}



根据类型名和类型的选择倾向获取类型 


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em type\+\_\+name} & ：类型名 \\
\hline
\mbox{\texttt{ in}}  & {\em type\+\_\+prefer} & ：类型选择倾向 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
前半部分为指向获取到的类型链头结点指针，后半部分为获取结果 
\end{DoxyReturn}
\begin{DoxyNote}{注解}
添加类型的规则见\+Type\+Data\+::\+Add\+Type的注释 \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_1_1TypeData_a58716d70558dd04ec69f7c7fab5fb398}{Type\+Data\+::\+Add\+Type}} 
\end{DoxyNote}


在文件 type\+\_\+system.\+cpp 第 47 行定义.



引用了 Get\+Type\+Name\+To\+Node() , 以及 c\+\_\+parser\+\_\+frontend\+::type\+\_\+system\+::k\+Type\+Name\+Not\+Found.



被这些函数引用 c\+\_\+parser\+\_\+frontend\+::\+C\+Parser\+Frontend\+::\+Get\+Type().

函数调用图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classc__parser__frontend_1_1type__system_1_1TypeSystem_aced9a8ca3d94b1528984e203601df3ff_cgraph}
\end{center}
\end{figure}
这是这个函数的调用关系图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classc__parser__frontend_1_1type__system_1_1TypeSystem_aced9a8ca3d94b1528984e203601df3ff_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classc__parser__frontend_1_1type__system_1_1TypeSystem_a758de256c4f407f85ef4a1113075b2a1}\label{classc__parser__frontend_1_1type__system_1_1TypeSystem_a758de256c4f407f85ef4a1113075b2a1}} 
\index{c\_parser\_frontend::type\_system::TypeSystem@{c\_parser\_frontend::type\_system::TypeSystem}!GetTypeNameToNode@{GetTypeNameToNode}}
\index{GetTypeNameToNode@{GetTypeNameToNode}!c\_parser\_frontend::type\_system::TypeSystem@{c\_parser\_frontend::type\_system::TypeSystem}}
\doxysubsubsection{\texorpdfstring{GetTypeNameToNode()}{GetTypeNameToNode()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_a8031776633f7d935b30ff78a1cbf9e7f}{Type\+Node\+Container\+Type}}\& c\+\_\+parser\+\_\+frontend\+::type\+\_\+system\+::\+Type\+System\+::\+Get\+Type\+Name\+To\+Node (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}



获取全部类型名到类型链的映射 

\begin{DoxyReturn}{返回}
返回存储类型名到类型链映射容器的引用 
\end{DoxyReturn}


在文件 type\+\_\+system.\+h 第 1208 行定义.



引用了 type\+\_\+name\+\_\+to\+\_\+node\+\_\+.



被这些函数引用 Define\+Type() , 以及 Get\+Type().

这是这个函数的调用关系图\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classc__parser__frontend_1_1type__system_1_1TypeSystem_a758de256c4f407f85ef4a1113075b2a1_icgraph}
\end{center}
\end{figure}


\doxysubsection{类成员变量说明}
\mbox{\Hypertarget{classc__parser__frontend_1_1type__system_1_1TypeSystem_a4472c8e3a047310c47754dcf0be70f80}\label{classc__parser__frontend_1_1type__system_1_1TypeSystem_a4472c8e3a047310c47754dcf0be70f80}} 
\index{c\_parser\_frontend::type\_system::TypeSystem@{c\_parser\_frontend::type\_system::TypeSystem}!type\_name\_to\_node\_@{type\_name\_to\_node\_}}
\index{type\_name\_to\_node\_@{type\_name\_to\_node\_}!c\_parser\_frontend::type\_system::TypeSystem@{c\_parser\_frontend::type\_system::TypeSystem}}
\doxysubsubsection{\texorpdfstring{type\_name\_to\_node\_}{type\_name\_to\_node\_}}
{\footnotesize\ttfamily \mbox{\hyperlink{classc__parser__frontend_1_1type__system_1_1TypeSystem_a8031776633f7d935b30ff78a1cbf9e7f}{Type\+Node\+Container\+Type}} c\+\_\+parser\+\_\+frontend\+::type\+\_\+system\+::\+Type\+System\+::type\+\_\+name\+\_\+to\+\_\+node\+\_\+\hspace{0.3cm}{\ttfamily [private]}}



保存类型名到类型链的映射 



在文件 type\+\_\+system.\+h 第 1210 行定义.



被这些函数引用 Get\+Type\+Name\+To\+Node().



该类的文档由以下文件生成\+:\begin{DoxyCompactItemize}
\item 
src/\+C\+Parser\+Frontend/\mbox{\hyperlink{type__system_8h}{type\+\_\+system.\+h}}\item 
src/\+C\+Parser\+Frontend/\mbox{\hyperlink{type__system_8cpp}{type\+\_\+system.\+cpp}}\end{DoxyCompactItemize}
