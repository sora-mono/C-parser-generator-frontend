<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Compliner Frontend Generator: c_parser_frontend::type_system::FunctionType类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Compliner Frontend Generator
   </div>
   <div id="projectbrief">编译器前端生成器</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classc__parser__frontend_1_1type__system_1_1FunctionType.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">类</a> &#124;
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pub-static-methods">静态 Public 成员函数</a> &#124;
<a href="#pri-types">Private 类型</a> &#124;
<a href="#pri-attribs">Private 属性</a> &#124;
<a href="classc__parser__frontend_1_1type__system_1_1FunctionType-members.html">所有成员列表</a>  </div>
  <div class="headertitle">
<div class="title">c_parser_frontend::type_system::FunctionType类 参考</div>  </div>
</div><!--header-->
<div class="contents">

<p>函数类型  
 <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="type__system_8h_source.html">type_system.h</a>&gt;</code></p>
<div class="dynheader">
类 c_parser_frontend::type_system::FunctionType 继承关系图:</div>
<div class="dyncontent">
<div class="center"><img src="classc__parser__frontend_1_1type__system_1_1FunctionType__inherit__graph.png" border="0" usemap="#c__parser__frontend_1_1type__system_1_1FunctionType_inherit__map" alt="Inheritance graph"/></div>
<map name="c__parser__frontend_1_1type__system_1_1FunctionType_inherit__map" id="c__parser__frontend_1_1type__system_1_1FunctionType_inherit__map">
<area shape="rect" title="函数类型" alt="" coords="7,95,206,136"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html" title="类型基类" alt="" coords="5,5,208,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">图例</a>]</span></center></div>
<div class="dynheader">
c_parser_frontend::type_system::FunctionType 的协作图:</div>
<div class="dyncontent">
<div class="center"><img src="classc__parser__frontend_1_1type__system_1_1FunctionType__coll__graph.png" border="0" usemap="#c__parser__frontend_1_1type__system_1_1FunctionType_coll__map" alt="Collaboration graph"/></div>
<map name="c__parser__frontend_1_1type__system_1_1FunctionType_coll__map" id="c__parser__frontend_1_1type__system_1_1FunctionType_coll__map">
<area shape="rect" title="函数类型" alt="" coords="7,95,206,136"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html" title="类型基类" alt="" coords="5,5,208,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">图例</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc__parser__frontend_1_1type__system_1_1FunctionType_1_1ArgumentInfo.html">ArgumentInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">存储函数参数信息  <a href="structc__parser__frontend_1_1type__system_1_1FunctionType_1_1ArgumentInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a1285219399f46eb5d0869d86cad07a22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a1285219399f46eb5d0869d86cad07a22">FunctionType</a> (const std::string &amp;function_name)</td></tr>
<tr class="separator:a1285219399f46eb5d0869d86cad07a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e09d5f076d5de1be1531fc17c9ed08"><td class="memTemplParams" colspan="2">template&lt;class ArgumentContainter &gt; </td></tr>
<tr class="memitem:ac7e09d5f076d5de1be1531fc17c9ed08"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ac7e09d5f076d5de1be1531fc17c9ed08">FunctionType</a> (const std::string &amp;function_name, ArgumentContainter &amp;&amp;argument_infos)</td></tr>
<tr class="separator:ac7e09d5f076d5de1be1531fc17c9ed08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f2e79f710057bfed4f2ac7cb0decc9"><td class="memTemplParams" colspan="2">template&lt;class ArgumentContainter &gt; </td></tr>
<tr class="memitem:a88f2e79f710057bfed4f2ac7cb0decc9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a88f2e79f710057bfed4f2ac7cb0decc9">FunctionType</a> (const std::string &amp;function_name, <a class="el" href="namespacec__parser__frontend_1_1type__system.html#a19d20e5542c29e0fbf656fc55ad88893">ConstTag</a> return_type_const_tag, const std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &gt; &amp;return_type, ArgumentContainter &amp;&amp;argument_infos)</td></tr>
<tr class="separator:a88f2e79f710057bfed4f2ac7cb0decc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fdbac52baf81b5ffae14d60daa6ad1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ac1fdbac52baf81b5ffae14d60daa6ad1">operator==</a> (const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &amp;type_interface) const override</td></tr>
<tr class="memdesc:ac1fdbac52baf81b5ffae14d60daa6ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">比较两个类型是否完全相同  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ac1fdbac52baf81b5ffae14d60daa6ad1">更多...</a><br /></td></tr>
<tr class="separator:ac1fdbac52baf81b5ffae14d60daa6ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ba29b09d464a6ac23089eaca85c83a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacec__parser__frontend_1_1type__system.html#abdba49f59bc164b6932d698ad6af20fe">AssignableCheckResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ab5ba29b09d464a6ac23089eaca85c83a">CanBeAssignedBy</a> (const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &amp;type_interface) const override</td></tr>
<tr class="memdesc:ab5ba29b09d464a6ac23089eaca85c83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">判断给定类型是否可以给该对象赋值  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ab5ba29b09d464a6ac23089eaca85c83a">更多...</a><br /></td></tr>
<tr class="separator:ab5ba29b09d464a6ac23089eaca85c83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e2646037df2235a323ed706f3e2a4d"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#aa3e2646037df2235a323ed706f3e2a4d">GetTypeStoreSize</a> () const override</td></tr>
<tr class="memdesc:aa3e2646037df2235a323ed706f3e2a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取存储该类型变量所需空间的大小  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#aa3e2646037df2235a323ed706f3e2a4d">更多...</a><br /></td></tr>
<tr class="separator:aa3e2646037df2235a323ed706f3e2a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3059126c5c2ab786e7a5f0e5bb42ecb7"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a3059126c5c2ab786e7a5f0e5bb42ecb7">TypeSizeOf</a> () const override</td></tr>
<tr class="memdesc:a3059126c5c2ab786e7a5f0e5bb42ecb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取sizeof语义下类型的大小  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a3059126c5c2ab786e7a5f0e5bb42ecb7">更多...</a><br /></td></tr>
<tr class="separator:a3059126c5c2ab786e7a5f0e5bb42ecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3e3f61b7d21a75ac86ef80075de7e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a2b3e3f61b7d21a75ac86ef80075de7e5">IsSameObject</a> (const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &amp;type_interface) const</td></tr>
<tr class="separator:a2b3e3f61b7d21a75ac86ef80075de7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415931fb8ef9d81ad8c6f09a1c4dbb92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a415931fb8ef9d81ad8c6f09a1c4dbb92">IsSameSignature</a> (const <a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html">FunctionType</a> &amp;function_type) const</td></tr>
<tr class="memdesc:a415931fb8ef9d81ad8c6f09a1c4dbb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">比较两个函数签名是否相同  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a415931fb8ef9d81ad8c6f09a1c4dbb92">更多...</a><br /></td></tr>
<tr class="separator:a415931fb8ef9d81ad8c6f09a1c4dbb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc96cef0f3e028e95151b20cb7e74fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#aafc96cef0f3e028e95151b20cb7e74fa">SetReturnTypePointer</a> (const std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &gt; &amp;return_type)</td></tr>
<tr class="memdesc:aafc96cef0f3e028e95151b20cb7e74fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置函数返回类型  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#aafc96cef0f3e028e95151b20cb7e74fa">更多...</a><br /></td></tr>
<tr class="separator:aafc96cef0f3e028e95151b20cb7e74fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ceb1362722fc80637688a47861fe80"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ae7ceb1362722fc80637688a47861fe80">GetReturnTypePointer</a> () const</td></tr>
<tr class="memdesc:ae7ceb1362722fc80637688a47861fe80"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取函数的返回类型链  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ae7ceb1362722fc80637688a47861fe80">更多...</a><br /></td></tr>
<tr class="separator:ae7ceb1362722fc80637688a47861fe80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a21bb0b5e78bd4a74f9f4e8fdff3a5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a66a21bb0b5e78bd4a74f9f4e8fdff3a5">GetReturnTypeReference</a> () const</td></tr>
<tr class="memdesc:a66a21bb0b5e78bd4a74f9f4e8fdff3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取函数的返回类型链头结点引用  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a66a21bb0b5e78bd4a74f9f4e8fdff3a5">更多...</a><br /></td></tr>
<tr class="separator:a66a21bb0b5e78bd4a74f9f4e8fdff3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc175d99b5aa6c34b59b9e54751fcc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a7cc175d99b5aa6c34b59b9e54751fcc9">SetReturnTypeConstTag</a> (<a class="el" href="namespacec__parser__frontend_1_1type__system.html#a19d20e5542c29e0fbf656fc55ad88893">ConstTag</a> return_type_const_tag)</td></tr>
<tr class="memdesc:a7cc175d99b5aa6c34b59b9e54751fcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置函数返回类型的const标记  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a7cc175d99b5aa6c34b59b9e54751fcc9">更多...</a><br /></td></tr>
<tr class="separator:a7cc175d99b5aa6c34b59b9e54751fcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8de558a64f6a4ef88598e3036b106c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacec__parser__frontend_1_1type__system.html#a19d20e5542c29e0fbf656fc55ad88893">ConstTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ae8de558a64f6a4ef88598e3036b106c4">GetReturnTypeConstTag</a> () const</td></tr>
<tr class="memdesc:ae8de558a64f6a4ef88598e3036b106c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取函数返回对象的const标记  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ae8de558a64f6a4ef88598e3036b106c4">更多...</a><br /></td></tr>
<tr class="separator:ae8de558a64f6a4ef88598e3036b106c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1adeb78e03105853f01622cf8b291d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a0e1adeb78e03105853f01622cf8b291d">AddFunctionCallArgument</a> (const std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1operator__node_1_1VarietyOperatorNode.html">c_parser_frontend::operator_node::VarietyOperatorNode</a> &gt; &amp;argument)</td></tr>
<tr class="memdesc:a0e1adeb78e03105853f01622cf8b291d"><td class="mdescLeft">&#160;</td><td class="mdescRight">添加函数参数  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a0e1adeb78e03105853f01622cf8b291d">更多...</a><br /></td></tr>
<tr class="separator:a0e1adeb78e03105853f01622cf8b291d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8f18f88e3d4aff6762bf06f741acb5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a5d40afc66329b413965e006d1091416a">ArgumentInfoContainer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a4e8f18f88e3d4aff6762bf06f741acb5">GetArguments</a> () const</td></tr>
<tr class="memdesc:a4e8f18f88e3d4aff6762bf06f741acb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取存储参数节点的容器  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a4e8f18f88e3d4aff6762bf06f741acb5">更多...</a><br /></td></tr>
<tr class="separator:a4e8f18f88e3d4aff6762bf06f741acb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7676a8d46745d04f9e1a3ce2ff5c0e1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a7676a8d46745d04f9e1a3ce2ff5c0e1d">SetFunctionName</a> (const std::string &amp;function_name)</td></tr>
<tr class="memdesc:a7676a8d46745d04f9e1a3ce2ff5c0e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置函数名  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a7676a8d46745d04f9e1a3ce2ff5c0e1d">更多...</a><br /></td></tr>
<tr class="separator:a7676a8d46745d04f9e1a3ce2ff5c0e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c2b063f5141ca6352f4bc872c96a8d"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ac6c2b063f5141ca6352f4bc872c96a8d">GetFunctionName</a> () const</td></tr>
<tr class="memdesc:ac6c2b063f5141ca6352f4bc872c96a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取函数名  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ac6c2b063f5141ca6352f4bc872c96a8d">更多...</a><br /></td></tr>
<tr class="separator:ac6c2b063f5141ca6352f4bc872c96a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface')"><img src="closed.png" alt="-"/>&#160;Public 成员函数 继承自 <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">c_parser_frontend::type_system::TypeInterface</a></td></tr>
<tr class="memitem:aa983e38720b70c7df9725592fbd2af9d inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#aa983e38720b70c7df9725592fbd2af9d">TypeInterface</a> (<a class="el" href="namespacec__parser__frontend_1_1type__system.html#a7ada2ff0eba2205e6a1c0c5afa2d5bd7">StructOrBasicType</a> type)</td></tr>
<tr class="separator:aa983e38720b70c7df9725592fbd2af9d inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5f31444179d4f38911444899aeac01 inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#a8e5f31444179d4f38911444899aeac01">TypeInterface</a> (<a class="el" href="namespacec__parser__frontend_1_1type__system.html#a7ada2ff0eba2205e6a1c0c5afa2d5bd7">StructOrBasicType</a> type, const std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &gt; &amp;next_type_node)</td></tr>
<tr class="separator:a8e5f31444179d4f38911444899aeac01 inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992abc416335c9fe58acb782862a089e inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#a992abc416335c9fe58acb782862a089e">~TypeInterface</a> ()</td></tr>
<tr class="separator:a992abc416335c9fe58acb782862a089e inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3027817a00d7034165ddc0fd56281da2 inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#a3027817a00d7034165ddc0fd56281da2">IsSameObject</a> (const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &amp;type_interface) const</td></tr>
<tr class="separator:a3027817a00d7034165ddc0fd56281da2 inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cd2d815957be2c795e8b7ae8fe7d55 inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#a37cd2d815957be2c795e8b7ae8fe7d55">SetType</a> (<a class="el" href="namespacec__parser__frontend_1_1type__system.html#a7ada2ff0eba2205e6a1c0c5afa2d5bd7">StructOrBasicType</a> type)</td></tr>
<tr class="memdesc:a37cd2d815957be2c795e8b7ae8fe7d55 inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置类型节点的类型  <a href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#a37cd2d815957be2c795e8b7ae8fe7d55">更多...</a><br /></td></tr>
<tr class="separator:a37cd2d815957be2c795e8b7ae8fe7d55 inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80e4319279851922698bef4223b1872 inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacec__parser__frontend_1_1type__system.html#a7ada2ff0eba2205e6a1c0c5afa2d5bd7">StructOrBasicType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#ae80e4319279851922698bef4223b1872">GetType</a> () const</td></tr>
<tr class="memdesc:ae80e4319279851922698bef4223b1872 inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取类型节点的类型  <a href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#ae80e4319279851922698bef4223b1872">更多...</a><br /></td></tr>
<tr class="separator:ae80e4319279851922698bef4223b1872 inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0d7c335ee3fa545379099dcddf6635 inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#aee0d7c335ee3fa545379099dcddf6635">GetNextNodePointer</a> () const</td></tr>
<tr class="memdesc:aee0d7c335ee3fa545379099dcddf6635 inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取下一个类型节点的指针  <a href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#aee0d7c335ee3fa545379099dcddf6635">更多...</a><br /></td></tr>
<tr class="separator:aee0d7c335ee3fa545379099dcddf6635 inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cec75839b33ca3ed3e3e8df0fabaa5 inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#ac8cec75839b33ca3ed3e3e8df0fabaa5">SetNextNode</a> (const std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &gt; &amp;next_type_node)</td></tr>
<tr class="memdesc:ac8cec75839b33ca3ed3e3e8df0fabaa5 inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置下一个节点  <a href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#ac8cec75839b33ca3ed3e3e8df0fabaa5">更多...</a><br /></td></tr>
<tr class="separator:ac8cec75839b33ca3ed3e3e8df0fabaa5 inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d34d13bdf090ead4b5c27f92250a63d inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#a7d34d13bdf090ead4b5c27f92250a63d">GetNextNodeReference</a> () const</td></tr>
<tr class="memdesc:a7d34d13bdf090ead4b5c27f92250a63d inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取下一个节点的引用  <a href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#a7d34d13bdf090ead4b5c27f92250a63d">更多...</a><br /></td></tr>
<tr class="separator:a7d34d13bdf090ead4b5c27f92250a63d inherit pub_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
静态 Public 成员函数</h2></td></tr>
<tr class="memitem:a4ce5142f48e20ce27e30a88e9ba104bd"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1type__system_1_1PointerType.html">PointerType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a4ce5142f48e20ce27e30a88e9ba104bd">ConvertToFunctionPointer</a> (const std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &gt; &amp;function_type)</td></tr>
<tr class="memdesc:a4ce5142f48e20ce27e30a88e9ba104bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取函数类型的函数指针形式  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a4ce5142f48e20ce27e30a88e9ba104bd">更多...</a><br /></td></tr>
<tr class="separator:a4ce5142f48e20ce27e30a88e9ba104bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface')"><img src="closed.png" alt="-"/>&#160;静态 Public 成员函数 继承自 <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">c_parser_frontend::type_system::TypeInterface</a></td></tr>
<tr class="memitem:a3869da413ff452a2a79b3e66602ee8a2 inherit pub_static_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1type__system_1_1PointerType.html">PointerType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#a3869da413ff452a2a79b3e66602ee8a2">ObtainAddressOperatorNode</a> (const std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &gt; &amp;type_interface, <a class="el" href="namespacec__parser__frontend_1_1type__system.html#a19d20e5542c29e0fbf656fc55ad88893">ConstTag</a> variety_const_tag)</td></tr>
<tr class="memdesc:a3869da413ff452a2a79b3e66602ee8a2 inherit pub_static_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取给定类型取地址后得到的类型  <a href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#a3869da413ff452a2a79b3e66602ee8a2">更多...</a><br /></td></tr>
<tr class="separator:a3869da413ff452a2a79b3e66602ee8a2 inherit pub_static_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c5e80b4b4140e77678fee207655160 inherit pub_static_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &gt;, <a class="el" href="namespacec__parser__frontend_1_1type__system.html#abda2c7df23bef8ddeaa9244a62fd8d2b">DeclineMathematicalComputeTypeResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#a62c5e80b4b4140e77678fee207655160">DeclineMathematicalComputeResult</a> (const std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &gt; &amp;left_compute_type, const std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &gt; &amp;right_compute_type)</td></tr>
<tr class="memdesc:a62c5e80b4b4140e77678fee207655160 inherit pub_static_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">推断两个类型进行数学运算后得到的类型和运算情况  <a href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#a62c5e80b4b4140e77678fee207655160">更多...</a><br /></td></tr>
<tr class="separator:a62c5e80b4b4140e77678fee207655160 inherit pub_static_methods_classc__parser__frontend_1_1type__system_1_1TypeInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private 类型</h2></td></tr>
<tr class="memitem:a5d40afc66329b413965e006d1091416a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a5d40afc66329b413965e006d1091416a">ArgumentInfoContainer</a> = std::vector&lt; <a class="el" href="structc__parser__frontend_1_1type__system_1_1FunctionType_1_1ArgumentInfo.html">ArgumentInfo</a> &gt;</td></tr>
<tr class="memdesc:a5d40afc66329b413965e006d1091416a"><td class="mdescLeft">&#160;</td><td class="mdescRight">存储参数信息的容器  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a5d40afc66329b413965e006d1091416a">更多...</a><br /></td></tr>
<tr class="separator:a5d40afc66329b413965e006d1091416a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private 属性</h2></td></tr>
<tr class="memitem:a62ec05a3efbda646f7477ba8d680772a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a62ec05a3efbda646f7477ba8d680772a">function_name_</a></td></tr>
<tr class="memdesc:a62ec05a3efbda646f7477ba8d680772a"><td class="mdescLeft">&#160;</td><td class="mdescRight">函数名  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a62ec05a3efbda646f7477ba8d680772a">更多...</a><br /></td></tr>
<tr class="separator:a62ec05a3efbda646f7477ba8d680772a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7869a19df36f30da50b6971fd41cbde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacec__parser__frontend_1_1type__system.html#a19d20e5542c29e0fbf656fc55ad88893">ConstTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ad7869a19df36f30da50b6971fd41cbde">return_type_const_tag_</a></td></tr>
<tr class="memdesc:ad7869a19df36f30da50b6971fd41cbde"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回值的const标记  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ad7869a19df36f30da50b6971fd41cbde">更多...</a><br /></td></tr>
<tr class="separator:ad7869a19df36f30da50b6971fd41cbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd6f072caa09000b81f07f38cf1eb70"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a1bd6f072caa09000b81f07f38cf1eb70">return_type_</a></td></tr>
<tr class="memdesc:a1bd6f072caa09000b81f07f38cf1eb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">函数返回类型  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a1bd6f072caa09000b81f07f38cf1eb70">更多...</a><br /></td></tr>
<tr class="separator:a1bd6f072caa09000b81f07f38cf1eb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf1b6d2efb3a593b2bf57fbcfc4574c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a5d40afc66329b413965e006d1091416a">ArgumentInfoContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a6cf1b6d2efb3a593b2bf57fbcfc4574c">argument_infos_</a></td></tr>
<tr class="memdesc:a6cf1b6d2efb3a593b2bf57fbcfc4574c"><td class="mdescLeft">&#160;</td><td class="mdescRight">参数类型和参数名  <a href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a6cf1b6d2efb3a593b2bf57fbcfc4574c">更多...</a><br /></td></tr>
<tr class="separator:a6cf1b6d2efb3a593b2bf57fbcfc4574c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>函数类型 </p>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00455">455</a> 行定义.</p>
</div><h2 class="groupheader">成员类型定义说明</h2>
<a id="a5d40afc66329b413965e006d1091416a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d40afc66329b413965e006d1091416a">&#9670;&nbsp;</a></span>ArgumentInfoContainer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a5d40afc66329b413965e006d1091416a">c_parser_frontend::type_system::FunctionType::ArgumentInfoContainer</a> =  std::vector&lt;<a class="el" href="structc__parser__frontend_1_1type__system_1_1FunctionType_1_1ArgumentInfo.html">ArgumentInfo</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>存储参数信息的容器 </p>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00469">469</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">构造及析构函数说明</h2>
<a id="a1285219399f46eb5d0869d86cad07a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1285219399f46eb5d0869d86cad07a22">&#9670;&nbsp;</a></span>FunctionType() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">c_parser_frontend::type_system::FunctionType::FunctionType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>function_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00472">472</a> 行定义.</p>

</div>
</div>
<a id="ac7e09d5f076d5de1be1531fc17c9ed08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e09d5f076d5de1be1531fc17c9ed08">&#9670;&nbsp;</a></span>FunctionType() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ArgumentContainter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">c_parser_frontend::type_system::FunctionType::FunctionType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>function_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgumentContainter &amp;&amp;&#160;</td>
          <td class="paramname"><em>argument_infos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00476">476</a> 行定义.</p>

</div>
</div>
<a id="a88f2e79f710057bfed4f2ac7cb0decc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f2e79f710057bfed4f2ac7cb0decc9">&#9670;&nbsp;</a></span>FunctionType() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ArgumentContainter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">c_parser_frontend::type_system::FunctionType::FunctionType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>function_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacec__parser__frontend_1_1type__system.html#a19d20e5542c29e0fbf656fc55ad88893">ConstTag</a>&#160;</td>
          <td class="paramname"><em>return_type_const_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>return_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgumentContainter &amp;&amp;&#160;</td>
          <td class="paramname"><em>argument_infos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00482">482</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="a0e1adeb78e03105853f01622cf8b291d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1adeb78e03105853f01622cf8b291d">&#9670;&nbsp;</a></span>AddFunctionCallArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void c_parser_frontend::type_system::FunctionType::AddFunctionCallArgument </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1operator__node_1_1VarietyOperatorNode.html">c_parser_frontend::operator_node::VarietyOperatorNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>argument</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>添加函数参数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argument</td><td>：根据参数类型和参数名构建的参数变量节点 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="operator__node_8cpp_source.html">operator_node.cpp</a> 第 <a class="el" href="operator__node_8cpp_source.html#l01100">1100</a> 行定义.</p>

<p class="reference">引用了 <a class="el" href="type__system_8h_source.html#l00583">argument_infos_</a>.</p>

<p class="reference">被这些函数引用 <a class="el" href="reduct__functions_8h_source.html#l00145">c_parser_frontend::parse_functions::ObjectConstructData::AddFunctionTypeArgument()</a>.</p>
<div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="classc__parser__frontend_1_1type__system_1_1FunctionType_a0e1adeb78e03105853f01622cf8b291d_icgraph.png" border="0" usemap="#classc__parser__frontend_1_1type__system_1_1FunctionType_a0e1adeb78e03105853f01622cf8b291d_icgraph" alt=""/></div>
<map name="classc__parser__frontend_1_1type__system_1_1FunctionType_a0e1adeb78e03105853f01622cf8b291d_icgraph" id="classc__parser__frontend_1_1type__system_1_1FunctionType_a0e1adeb78e03105853f01622cf8b291d_icgraph">
<area shape="rect" title="添加函数参数" alt="" coords="291,5,489,61"/>
<area shape="rect" href="classc__parser__frontend_1_1parse__functions_1_1ObjectConstructData.html#ab98eb8324f0961e5672b17850d2b2188" title="向尾部节点添加函数参数，要求尾部节点为函数类型" alt="" coords="5,5,243,61"/>
</map>
</div>

</div>
</div>
<a id="ab5ba29b09d464a6ac23089eaca85c83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ba29b09d464a6ac23089eaca85c83a">&#9670;&nbsp;</a></span>CanBeAssignedBy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacec__parser__frontend_1_1type__system.html#abdba49f59bc164b6932d698ad6af20fe">AssignableCheckResult</a> c_parser_frontend::type_system::FunctionType::CanBeAssignedBy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>type_interface</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>判断给定类型是否可以给该对象赋值 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_interface</td><td>：待判断的类型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回检查结果 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>返回值的意义见其定义 </dd></dl>

<p>实现了 <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#a669b266fbf7be6477db5464916d7ddc6">c_parser_frontend::type_system::TypeInterface</a>.</p>

<p class="definition">在文件 <a class="el" href="type__system_8cpp_source.html">type_system.cpp</a> 第 <a class="el" href="type__system_8cpp_source.html#l00176">176</a> 行定义.</p>

<p class="reference">引用了 <a class="el" href="type__system_8h_source.html#l00238">c_parser_frontend::type_system::TypeInterface::IsSameObject()</a>, <a class="el" href="type__system_8h_source.html#l00516">IsSameSignature()</a>, <a class="el" href="namespacec__parser__frontend_1_1type__system.html#abdba49f59bc164b6932d698ad6af20fea2862445348e9bafbfb3cd27e60cfc839">c_parser_frontend::type_system::kCanNotConvert</a> , 以及 <a class="el" href="namespacec__parser__frontend_1_1type__system.html#abdba49f59bc164b6932d698ad6af20fea45fe6ae08611c6edceca614084703ff6">c_parser_frontend::type_system::kNonConvert</a>.</p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classc__parser__frontend_1_1type__system_1_1FunctionType_ab5ba29b09d464a6ac23089eaca85c83a_cgraph.png" border="0" usemap="#classc__parser__frontend_1_1type__system_1_1FunctionType_ab5ba29b09d464a6ac23089eaca85c83a_cgraph" alt=""/></div>
<map name="classc__parser__frontend_1_1type__system_1_1FunctionType_ab5ba29b09d464a6ac23089eaca85c83a_cgraph" id="classc__parser__frontend_1_1type__system_1_1FunctionType_ab5ba29b09d464a6ac23089eaca85c83a_cgraph">
<area shape="rect" title="判断给定类型是否可以给该对象赋值" alt="" coords="5,85,204,141"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#a3027817a00d7034165ddc0fd56281da2" title=" " alt="" coords="252,25,455,81"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a415931fb8ef9d81ad8c6f09a1c4dbb92" title="比较两个函数签名是否相同" alt="" coords="254,125,453,181"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#ae80e4319279851922698bef4223b1872" title="获取类型节点的类型" alt="" coords="503,5,705,61"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a4e8f18f88e3d4aff6762bf06f741acb5" title="获取存储参数节点的容器" alt="" coords="505,85,703,141"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ac6c2b063f5141ca6352f4bc872c96a8d" title="获取函数名" alt="" coords="505,165,703,221"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a66a21bb0b5e78bd4a74f9f4e8fdff3a5" title="获取函数的返回类型链头结点引用" alt="" coords="505,245,703,301"/>
</map>
</div>

</div>
</div>
<a id="a4ce5142f48e20ce27e30a88e9ba104bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce5142f48e20ce27e30a88e9ba104bd">&#9670;&nbsp;</a></span>ConvertToFunctionPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;const <a class="el" href="classc__parser__frontend_1_1type__system_1_1PointerType.html">PointerType</a>&gt; c_parser_frontend::type_system::FunctionType::ConvertToFunctionPointer </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>function_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取函数类型的函数指针形式 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function_type</td><td>：待获取指针形式的函数类型节点 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回函数的一重函数指针形式</dd></dl>
<p>返回一个const指针节点，这个指针节点指向function_type节点 </p>
<p>转除const为了可以构造指针节点，不会修改function_type</p>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00567">567</a> 行定义.</p>

<p class="reference">引用了 <a class="el" href="namespacec__parser__frontend_1_1type__system.html#a19d20e5542c29e0fbf656fc55ad88893ad1efdc0f2aa096a47586b448aa73f414">c_parser_frontend::type_system::kConst</a> , 以及 <a class="el" href="namespacec__parser__frontend_1_1type__system.html#a7ada2ff0eba2205e6a1c0c5afa2d5bd7ad77fcb77da3dc9a391cbdfd264f8d7d9">c_parser_frontend::type_system::kFunction</a>.</p>

</div>
</div>
<a id="a4e8f18f88e3d4aff6762bf06f741acb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8f18f88e3d4aff6762bf06f741acb5">&#9670;&nbsp;</a></span>GetArguments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a5d40afc66329b413965e006d1091416a">ArgumentInfoContainer</a>&amp; c_parser_frontend::type_system::FunctionType::GetArguments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取存储参数节点的容器 </p>
<dl class="section return"><dt>返回</dt><dd>返回存储参数节点的容器的const引用 </dd></dl>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00553">553</a> 行定义.</p>

<p class="reference">引用了 <a class="el" href="type__system_8h_source.html#l00583">argument_infos_</a>.</p>

<p class="reference">被这些函数引用 <a class="el" href="type__system_8h_source.html#l00516">IsSameSignature()</a> , 以及 <a class="el" href="acion__scope__system_8cpp_source.html#l00184">c_parser_frontend::action_scope_system::ActionScopeSystem::SetFunctionToConstruct()</a>.</p>
<div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="classc__parser__frontend_1_1type__system_1_1FunctionType_a4e8f18f88e3d4aff6762bf06f741acb5_icgraph.png" border="0" usemap="#classc__parser__frontend_1_1type__system_1_1FunctionType_a4e8f18f88e3d4aff6762bf06f741acb5_icgraph" alt=""/></div>
<map name="classc__parser__frontend_1_1type__system_1_1FunctionType_a4e8f18f88e3d4aff6762bf06f741acb5_icgraph" id="classc__parser__frontend_1_1type__system_1_1FunctionType_a4e8f18f88e3d4aff6762bf06f741acb5_icgraph">
<area shape="rect" title="获取存储参数节点的容器" alt="" coords="777,137,976,193"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a415931fb8ef9d81ad8c6f09a1c4dbb92" title="比较两个函数签名是否相同" alt="" coords="531,93,729,149"/>
<area shape="rect" href="classc__parser__frontend_1_1action__scope__system_1_1ActionScopeSystem.html#ac44ad28c95778bb6ca7fc51eee472f80" title="设置当前待构建函数" alt="" coords="543,174,717,245"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ab5ba29b09d464a6ac23089eaca85c83a" title="判断给定类型是否可以给该对象赋值" alt="" coords="265,5,464,61"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1TypeSystem_1_1TypeData.html#a14ad72a299ae2ac3ec015a00f1f5a824" title="检查已存在函数声明/定义条件下添加同名函数声明/定义的错误情况" alt="" coords="247,86,483,157"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1TypeSystem_1_1TypeData.html#a58716d70558dd04ec69f7c7fab5fb398" title="添加一个类型" alt="" coords="5,93,199,149"/>
<area shape="rect" href="classc__parser__frontend_1_1CParserFrontend.html#aa27c730d6112f2cf35380d8c98520349" title="设置当前待构建函数" alt="" coords="259,181,471,237"/>
</map>
</div>

</div>
</div>
<a id="ac6c2b063f5141ca6352f4bc872c96a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c2b063f5141ca6352f4bc872c96a8d">&#9670;&nbsp;</a></span>GetFunctionName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; c_parser_frontend::type_system::FunctionType::GetFunctionName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取函数名 </p>
<dl class="section return"><dt>返回</dt><dd>返回函数名的const引用 </dd></dl>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00561">561</a> 行定义.</p>

<p class="reference">引用了 <a class="el" href="type__system_8h_source.html#l00577">function_name_</a>.</p>

<p class="reference">被这些函数引用 <a class="el" href="type__system_8h_source.html#l00516">IsSameSignature()</a> , 以及 <a class="el" href="acion__scope__system_8cpp_source.html#l00160">c_parser_frontend::action_scope_system::ActionScopeSystem::PushFunctionFlowControlNode()</a>.</p>
<div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="classc__parser__frontend_1_1type__system_1_1FunctionType_ac6c2b063f5141ca6352f4bc872c96a8d_icgraph.png" border="0" usemap="#classc__parser__frontend_1_1type__system_1_1FunctionType_ac6c2b063f5141ca6352f4bc872c96a8d_icgraph" alt=""/></div>
<map name="classc__parser__frontend_1_1type__system_1_1FunctionType_ac6c2b063f5141ca6352f4bc872c96a8d_icgraph" id="classc__parser__frontend_1_1type__system_1_1FunctionType_ac6c2b063f5141ca6352f4bc872c96a8d_icgraph">
<area shape="rect" title="获取函数名" alt="" coords="817,140,1016,196"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a415931fb8ef9d81ad8c6f09a1c4dbb92" title="比较两个函数签名是否相同" alt="" coords="560,93,759,149"/>
<area shape="rect" href="classc__parser__frontend_1_1action__scope__system_1_1ActionScopeSystem.html#ac01d17fed7775b3fa28fc332b0ec1de9" title="创建函数定义控制块并压入流程控制节点栈中" alt="" coords="549,177,769,247"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ab5ba29b09d464a6ac23089eaca85c83a" title="判断给定类型是否可以给该对象赋值" alt="" coords="284,5,483,61"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1TypeSystem_1_1TypeData.html#a14ad72a299ae2ac3ec015a00f1f5a824" title="检查已存在函数声明/定义条件下添加同名函数声明/定义的错误情况" alt="" coords="265,86,501,157"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1TypeSystem_1_1TypeData.html#a58716d70558dd04ec69f7c7fab5fb398" title="添加一个类型" alt="" coords="15,93,208,149"/>
<area shape="rect" href="classc__parser__frontend_1_1action__scope__system_1_1ActionScopeSystem.html#ac44ad28c95778bb6ca7fc51eee472f80" title="设置当前待构建函数" alt="" coords="296,181,471,251"/>
<area shape="rect" href="classc__parser__frontend_1_1CParserFrontend.html#aa27c730d6112f2cf35380d8c98520349" title="设置当前待构建函数" alt="" coords="5,188,217,244"/>
</map>
</div>

</div>
</div>
<a id="ae8de558a64f6a4ef88598e3036b106c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8de558a64f6a4ef88598e3036b106c4">&#9670;&nbsp;</a></span>GetReturnTypeConstTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacec__parser__frontend_1_1type__system.html#a19d20e5542c29e0fbf656fc55ad88893">ConstTag</a> c_parser_frontend::type_system::FunctionType::GetReturnTypeConstTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取函数返回对象的const标记 </p>
<dl class="section return"><dt>返回</dt><dd>返回函数返回对象的const标记 </dd></dl>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00544">544</a> 行定义.</p>

<p class="reference">引用了 <a class="el" href="type__system_8h_source.html#l00579">return_type_const_tag_</a>.</p>

</div>
</div>
<a id="ae7ceb1362722fc80637688a47861fe80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ceb1362722fc80637688a47861fe80">&#9670;&nbsp;</a></span>GetReturnTypePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a>&gt; c_parser_frontend::type_system::FunctionType::GetReturnTypePointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取函数的返回类型链 </p>
<dl class="section return"><dt>返回</dt><dd>返回指向函数的返回类型链头结点的指针 </dd></dl>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00529">529</a> 行定义.</p>

<p class="reference">引用了 <a class="el" href="type__system_8h_source.html#l00581">return_type_</a>.</p>

<p class="reference">被这些函数引用 <a class="el" href="flow__control_8cpp_source.html#l00299">c_parser_frontend::flow_control::FunctionDefine::CheckSentenceInFunctionValid()</a>.</p>
<div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="classc__parser__frontend_1_1type__system_1_1FunctionType_ae7ceb1362722fc80637688a47861fe80_icgraph.png" border="0" usemap="#classc__parser__frontend_1_1type__system_1_1FunctionType_ae7ceb1362722fc80637688a47861fe80_icgraph" alt=""/></div>
<map name="classc__parser__frontend_1_1type__system_1_1FunctionType_ae7ceb1362722fc80637688a47861fe80_icgraph" id="classc__parser__frontend_1_1type__system_1_1FunctionType_ae7ceb1362722fc80637688a47861fe80_icgraph">
<area shape="rect" title="获取函数的返回类型链" alt="" coords="792,45,991,101"/>
<area shape="rect" href="classc__parser__frontend_1_1flow__control_1_1FunctionDefine.html#aaf0729f7e7c809dad9814ec9fecf5fe5" title="检查给定语句是否可以作为函数内执行的语句" alt="" coords="515,45,744,101"/>
<area shape="rect" href="classc__parser__frontend_1_1flow__control_1_1FunctionDefine.html#a80ece7836e0b60e9abace2aef88b7f6e" title="添加一条函数内执行的语句" alt="" coords="260,5,467,61"/>
<area shape="rect" href="classc__parser__frontend_1_1flow__control_1_1FunctionDefine.html#a1197ee4a48e2d37c82b402f6bd01246a" title="添加一个容器内的全部语句" alt="" coords="260,85,467,141"/>
<area shape="rect" href="classc__parser__frontend_1_1flow__control_1_1FunctionDefine.html#a73416179a5655fc54cd037f7d9a43f43" title="向流程语句主体中中添加单条语句" alt="" coords="5,5,212,61"/>
<area shape="rect" href="classc__parser__frontend_1_1flow__control_1_1FunctionDefine.html#a4e41329fb34ed861cb4ffa6e1677271d" title="向流程语句主体中中添加多条语句" alt="" coords="5,85,212,141"/>
</map>
</div>

</div>
</div>
<a id="a66a21bb0b5e78bd4a74f9f4e8fdff3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a21bb0b5e78bd4a74f9f4e8fdff3a5">&#9670;&nbsp;</a></span>GetReturnTypeReference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a>&amp; c_parser_frontend::type_system::FunctionType::GetReturnTypeReference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取函数的返回类型链头结点引用 </p>
<dl class="section return"><dt>返回</dt><dd>返回函数的返回类型链头结点的const引用 </dd></dl>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00534">534</a> 行定义.</p>

<p class="reference">引用了 <a class="el" href="type__system_8h_source.html#l00581">return_type_</a>.</p>

<p class="reference">被这些函数引用 <a class="el" href="type__system_8h_source.html#l00516">IsSameSignature()</a>.</p>
<div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="classc__parser__frontend_1_1type__system_1_1FunctionType_a66a21bb0b5e78bd4a74f9f4e8fdff3a5_icgraph.png" border="0" usemap="#classc__parser__frontend_1_1type__system_1_1FunctionType_a66a21bb0b5e78bd4a74f9f4e8fdff3a5_icgraph" alt=""/></div>
<map name="classc__parser__frontend_1_1type__system_1_1FunctionType_a66a21bb0b5e78bd4a74f9f4e8fdff3a5_icgraph" id="classc__parser__frontend_1_1type__system_1_1FunctionType_a66a21bb0b5e78bd4a74f9f4e8fdff3a5_icgraph">
<area shape="rect" title="获取函数的返回类型链头结点引用" alt="" coords="777,49,976,105"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a415931fb8ef9d81ad8c6f09a1c4dbb92" title="比较两个函数签名是否相同" alt="" coords="531,49,729,105"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ab5ba29b09d464a6ac23089eaca85c83a" title="判断给定类型是否可以给该对象赋值" alt="" coords="265,5,464,61"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1TypeSystem_1_1TypeData.html#a14ad72a299ae2ac3ec015a00f1f5a824" title="检查已存在函数声明/定义条件下添加同名函数声明/定义的错误情况" alt="" coords="247,86,483,157"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1TypeSystem_1_1TypeData.html#a58716d70558dd04ec69f7c7fab5fb398" title="添加一个类型" alt="" coords="5,93,199,149"/>
</map>
</div>

</div>
</div>
<a id="aa3e2646037df2235a323ed706f3e2a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e2646037df2235a323ed706f3e2a4d">&#9670;&nbsp;</a></span>GetTypeStoreSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t c_parser_frontend::type_system::FunctionType::GetTypeStoreSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取存储该类型变量所需空间的大小 </p>
<dl class="section return"><dt>返回</dt><dd>返回存储该类型变量所需空间大小 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>指针均为kPointerSize字节 </dd></dl>

<p>实现了 <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#af141ec273bfe24c2b4e662680d3bad9c">c_parser_frontend::type_system::TypeInterface</a>.</p>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00494">494</a> 行定义.</p>

</div>
</div>
<a id="a2b3e3f61b7d21a75ac86ef80075de7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3e3f61b7d21a75ac86ef80075de7e5">&#9670;&nbsp;</a></span>IsSameObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool c_parser_frontend::type_system::FunctionType::IsSameObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>type_interface</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00504">504</a> 行定义.</p>

<p class="reference">被这些函数引用 <a class="el" href="type__system_8cpp_source.html#l00169">operator==()</a>.</p>
<div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="classc__parser__frontend_1_1type__system_1_1FunctionType_a2b3e3f61b7d21a75ac86ef80075de7e5_icgraph.png" border="0" usemap="#classc__parser__frontend_1_1type__system_1_1FunctionType_a2b3e3f61b7d21a75ac86ef80075de7e5_icgraph" alt=""/></div>
<map name="classc__parser__frontend_1_1type__system_1_1FunctionType_a2b3e3f61b7d21a75ac86ef80075de7e5_icgraph" id="classc__parser__frontend_1_1type__system_1_1FunctionType_a2b3e3f61b7d21a75ac86ef80075de7e5_icgraph">
<area shape="rect" title=" " alt="" coords="252,5,451,61"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ac1fdbac52baf81b5ffae14d60daa6ad1" title="比较两个类型是否完全相同" alt="" coords="5,5,204,61"/>
</map>
</div>

</div>
</div>
<a id="a415931fb8ef9d81ad8c6f09a1c4dbb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415931fb8ef9d81ad8c6f09a1c4dbb92">&#9670;&nbsp;</a></span>IsSameSignature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool c_parser_frontend::type_system::FunctionType::IsSameSignature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html">FunctionType</a> &amp;&#160;</td>
          <td class="paramname"><em>function_type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>比较两个函数签名是否相同 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function_type</td><td>：用来比较的另一个函数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回两个函数签名是否相同 </dd></dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>：两个函数签名相同 </td></tr>
    <tr><td class="paramname">false</td><td>：两个函数签名不同</td></tr>
  </table>
  </dd>
</dl>
<p>检查两个函数类型的函数名、函数参数、返回类型是否相同 </p><dl class="section note"><dt>注解</dt><dd>只检查函数签名是否相同，不检查函数内执行的语句 </dd></dl>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00516">516</a> 行定义.</p>

<p class="reference">引用了 <a class="el" href="type__system_8h_source.html#l00553">GetArguments()</a>, <a class="el" href="type__system_8h_source.html#l00561">GetFunctionName()</a> , 以及 <a class="el" href="type__system_8h_source.html#l00534">GetReturnTypeReference()</a>.</p>

<p class="reference">被这些函数引用 <a class="el" href="type__system_8cpp_source.html#l00176">CanBeAssignedBy()</a> , 以及 <a class="el" href="type__system_8h_source.html#l01149">c_parser_frontend::type_system::TypeSystem::TypeData::CheckFunctionDefineAddResult()</a>.</p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classc__parser__frontend_1_1type__system_1_1FunctionType_a415931fb8ef9d81ad8c6f09a1c4dbb92_cgraph.png" border="0" usemap="#classc__parser__frontend_1_1type__system_1_1FunctionType_a415931fb8ef9d81ad8c6f09a1c4dbb92_cgraph" alt=""/></div>
<map name="classc__parser__frontend_1_1type__system_1_1FunctionType_a415931fb8ef9d81ad8c6f09a1c4dbb92_cgraph" id="classc__parser__frontend_1_1type__system_1_1FunctionType_a415931fb8ef9d81ad8c6f09a1c4dbb92_cgraph">
<area shape="rect" title="比较两个函数签名是否相同" alt="" coords="5,85,204,141"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a4e8f18f88e3d4aff6762bf06f741acb5" title="获取存储参数节点的容器" alt="" coords="252,5,451,61"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ac6c2b063f5141ca6352f4bc872c96a8d" title="获取函数名" alt="" coords="252,85,451,141"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a66a21bb0b5e78bd4a74f9f4e8fdff3a5" title="获取函数的返回类型链头结点引用" alt="" coords="252,165,451,221"/>
</map>
</div>
<div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="classc__parser__frontend_1_1type__system_1_1FunctionType_a415931fb8ef9d81ad8c6f09a1c4dbb92_icgraph.png" border="0" usemap="#classc__parser__frontend_1_1type__system_1_1FunctionType_a415931fb8ef9d81ad8c6f09a1c4dbb92_icgraph" alt=""/></div>
<map name="classc__parser__frontend_1_1type__system_1_1FunctionType_a415931fb8ef9d81ad8c6f09a1c4dbb92_icgraph" id="classc__parser__frontend_1_1type__system_1_1FunctionType_a415931fb8ef9d81ad8c6f09a1c4dbb92_icgraph">
<area shape="rect" title="比较两个函数签名是否相同" alt="" coords="531,49,729,105"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#ab5ba29b09d464a6ac23089eaca85c83a" title="判断给定类型是否可以给该对象赋值" alt="" coords="265,5,464,61"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1TypeSystem_1_1TypeData.html#a14ad72a299ae2ac3ec015a00f1f5a824" title="检查已存在函数声明/定义条件下添加同名函数声明/定义的错误情况" alt="" coords="247,86,483,157"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1TypeSystem_1_1TypeData.html#a58716d70558dd04ec69f7c7fab5fb398" title="添加一个类型" alt="" coords="5,93,199,149"/>
</map>
</div>

</div>
</div>
<a id="ac1fdbac52baf81b5ffae14d60daa6ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fdbac52baf81b5ffae14d60daa6ad1">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool c_parser_frontend::type_system::FunctionType::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>type_interface</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>比较两个类型是否完全相同 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_interface</td><td>：待比较的两个类型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回两个类型是否完全相同 </dd></dl>
<dl class="retval"><dt>返回值</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>：两个类型完全相同 </td></tr>
    <tr><td class="paramname">false</td><td>：两个类型不完全相同 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>自动调用下一级比较函数 </dd></dl>

<p>实现了 <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#a5aa9c19280d18ecedfc56f910f6d95bc">c_parser_frontend::type_system::TypeInterface</a>.</p>

<p class="definition">在文件 <a class="el" href="type__system_8cpp_source.html">type_system.cpp</a> 第 <a class="el" href="type__system_8cpp_source.html#l00169">169</a> 行定义.</p>

<p class="reference">引用了 <a class="el" href="type__system_8h_source.html#l00262">c_parser_frontend::type_system::TypeInterface::GetNextNodeReference()</a> , 以及 <a class="el" href="type__system_8h_source.html#l00504">IsSameObject()</a>.</p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classc__parser__frontend_1_1type__system_1_1FunctionType_ac1fdbac52baf81b5ffae14d60daa6ad1_cgraph.png" border="0" usemap="#classc__parser__frontend_1_1type__system_1_1FunctionType_ac1fdbac52baf81b5ffae14d60daa6ad1_cgraph" alt=""/></div>
<map name="classc__parser__frontend_1_1type__system_1_1FunctionType_ac1fdbac52baf81b5ffae14d60daa6ad1_cgraph" id="classc__parser__frontend_1_1type__system_1_1FunctionType_ac1fdbac52baf81b5ffae14d60daa6ad1_cgraph">
<area shape="rect" title="比较两个类型是否完全相同" alt="" coords="5,45,204,101"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#a7d34d13bdf090ead4b5c27f92250a63d" title="获取下一个节点的引用" alt="" coords="252,5,455,61"/>
<area shape="rect" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a2b3e3f61b7d21a75ac86ef80075de7e5" title=" " alt="" coords="254,85,453,141"/>
</map>
</div>

</div>
</div>
<a id="a7676a8d46745d04f9e1a3ce2ff5c0e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7676a8d46745d04f9e1a3ce2ff5c0e1d">&#9670;&nbsp;</a></span>SetFunctionName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_parser_frontend::type_system::FunctionType::SetFunctionName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>function_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置函数名 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">function_name</td><td>：函数名 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00556">556</a> 行定义.</p>

<p class="reference">引用了 <a class="el" href="type__system_8h_source.html#l00577">function_name_</a>.</p>

</div>
</div>
<a id="a7cc175d99b5aa6c34b59b9e54751fcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc175d99b5aa6c34b59b9e54751fcc9">&#9670;&nbsp;</a></span>SetReturnTypeConstTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_parser_frontend::type_system::FunctionType::SetReturnTypeConstTag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacec__parser__frontend_1_1type__system.html#a19d20e5542c29e0fbf656fc55ad88893">ConstTag</a>&#160;</td>
          <td class="paramname"><em>return_type_const_tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置函数返回类型的const标记 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">return_type_const_tag</td><td>：函数返回类型的const标记</td></tr>
  </table>
  </dd>
</dl>
<p>该属性决定返回的对象是否不可修改 </p>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00539">539</a> 行定义.</p>

<p class="reference">引用了 <a class="el" href="type__system_8h_source.html#l00579">return_type_const_tag_</a>.</p>

<p class="reference">被这些函数引用 <a class="el" href="reduct__functions_8cpp_source.html#l03332">c_parser_frontend::parse_functions::ObjectConstructData::ConstructObject()</a>.</p>
<div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="classc__parser__frontend_1_1type__system_1_1FunctionType_a7cc175d99b5aa6c34b59b9e54751fcc9_icgraph.png" border="0" usemap="#classc__parser__frontend_1_1type__system_1_1FunctionType_a7cc175d99b5aa6c34b59b9e54751fcc9_icgraph" alt=""/></div>
<map name="classc__parser__frontend_1_1type__system_1_1FunctionType_a7cc175d99b5aa6c34b59b9e54751fcc9_icgraph" id="classc__parser__frontend_1_1type__system_1_1FunctionType_a7cc175d99b5aa6c34b59b9e54751fcc9_icgraph">
<area shape="rect" title="设置函数返回类型的const标记" alt="" coords="291,5,489,61"/>
<area shape="rect" href="classc__parser__frontend_1_1parse__functions_1_1ObjectConstructData.html#a43157e073abf72995ee25488377ab23b" title=" " alt="" coords="5,5,243,61"/>
</map>
</div>

</div>
</div>
<a id="aafc96cef0f3e028e95151b20cb7e74fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc96cef0f3e028e95151b20cb7e74fa">&#9670;&nbsp;</a></span>SetReturnTypePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void c_parser_frontend::type_system::FunctionType::SetReturnTypePointer </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>return_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置函数返回类型 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">return_type</td><td>：指向函数返回类型类型链头结点的指针 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00523">523</a> 行定义.</p>

<p class="reference">引用了 <a class="el" href="type__system_8h_source.html#l00581">return_type_</a>.</p>

<p class="reference">被这些函数引用 <a class="el" href="reduct__functions_8cpp_source.html#l03286">c_parser_frontend::parse_functions::ObjectConstructData::AttachSingleNodeToTailNodePointer()</a>.</p>
<div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="classc__parser__frontend_1_1type__system_1_1FunctionType_aafc96cef0f3e028e95151b20cb7e74fa_icgraph.png" border="0" usemap="#classc__parser__frontend_1_1type__system_1_1FunctionType_aafc96cef0f3e028e95151b20cb7e74fa_icgraph" alt=""/></div>
<map name="classc__parser__frontend_1_1type__system_1_1FunctionType_aafc96cef0f3e028e95151b20cb7e74fa_icgraph" id="classc__parser__frontend_1_1type__system_1_1FunctionType_aafc96cef0f3e028e95151b20cb7e74fa_icgraph">
<area shape="rect" title="设置函数返回类型" alt="" coords="697,45,896,101"/>
<area shape="rect" href="classc__parser__frontend_1_1parse__functions_1_1ObjectConstructData.html#ab985b2af30412fb15a6166e1bfba1120" title="语义同AttachSingleNodeToTailNodeEmplace，参数使用已经构建好的节点" alt="" coords="356,45,649,101"/>
<area shape="rect" href="classc__parser__frontend_1_1parse__functions_1_1ObjectConstructData.html#ad0b60d21f8859a96666cf2e32d6c9e6a" title=" " alt="" coords="5,5,308,61"/>
<area shape="rect" href="classc__parser__frontend_1_1parse__functions_1_1ObjectConstructData.html#a43157e073abf72995ee25488377ab23b" title=" " alt="" coords="38,85,275,141"/>
</map>
</div>

</div>
</div>
<a id="a3059126c5c2ab786e7a5f0e5bb42ecb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3059126c5c2ab786e7a5f0e5bb42ecb7">&#9670;&nbsp;</a></span>TypeSizeOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t c_parser_frontend::type_system::FunctionType::TypeSizeOf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取sizeof语义下类型的大小 </p>
<dl class="section return"><dt>返回</dt><dd>返回sizeof语义下类型的大小 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>指向数组的指针结果为类型大小乘以各维度大小 </dd></dl>

<p>实现了 <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html#ac226ef7e7ae3877dcbbe6bc23433884e">c_parser_frontend::type_system::TypeInterface</a>.</p>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00499">499</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a id="a6cf1b6d2efb3a593b2bf57fbcfc4574c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf1b6d2efb3a593b2bf57fbcfc4574c">&#9670;&nbsp;</a></span>argument_infos_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html#a5d40afc66329b413965e006d1091416a">ArgumentInfoContainer</a> c_parser_frontend::type_system::FunctionType::argument_infos_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>参数类型和参数名 </p>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00583">583</a> 行定义.</p>

<p class="reference">被这些函数引用 <a class="el" href="operator__node_8cpp_source.html#l01100">AddFunctionCallArgument()</a> , 以及 <a class="el" href="type__system_8h_source.html#l00553">GetArguments()</a>.</p>

</div>
</div>
<a id="a62ec05a3efbda646f7477ba8d680772a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ec05a3efbda646f7477ba8d680772a">&#9670;&nbsp;</a></span>function_name_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string c_parser_frontend::type_system::FunctionType::function_name_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>函数名 </p>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00577">577</a> 行定义.</p>

<p class="reference">被这些函数引用 <a class="el" href="type__system_8h_source.html#l00561">GetFunctionName()</a> , 以及 <a class="el" href="type__system_8h_source.html#l00556">SetFunctionName()</a>.</p>

</div>
</div>
<a id="a1bd6f072caa09000b81f07f38cf1eb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd6f072caa09000b81f07f38cf1eb70">&#9670;&nbsp;</a></span>return_type_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classc__parser__frontend_1_1type__system_1_1TypeInterface.html">TypeInterface</a>&gt; c_parser_frontend::type_system::FunctionType::return_type_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>函数返回类型 </p>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00581">581</a> 行定义.</p>

<p class="reference">被这些函数引用 <a class="el" href="type__system_8h_source.html#l00529">GetReturnTypePointer()</a>, <a class="el" href="type__system_8h_source.html#l00534">GetReturnTypeReference()</a> , 以及 <a class="el" href="type__system_8h_source.html#l00523">SetReturnTypePointer()</a>.</p>

</div>
</div>
<a id="ad7869a19df36f30da50b6971fd41cbde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7869a19df36f30da50b6971fd41cbde">&#9670;&nbsp;</a></span>return_type_const_tag_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacec__parser__frontend_1_1type__system.html#a19d20e5542c29e0fbf656fc55ad88893">ConstTag</a> c_parser_frontend::type_system::FunctionType::return_type_const_tag_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回值的const标记 </p>

<p class="definition">在文件 <a class="el" href="type__system_8h_source.html">type_system.h</a> 第 <a class="el" href="type__system_8h_source.html#l00579">579</a> 行定义.</p>

<p class="reference">被这些函数引用 <a class="el" href="type__system_8h_source.html#l00544">GetReturnTypeConstTag()</a> , 以及 <a class="el" href="type__system_8h_source.html#l00539">SetReturnTypeConstTag()</a>.</p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>src/CParserFrontend/<a class="el" href="type__system_8h_source.html">type_system.h</a></li>
<li>src/CParserFrontend/<a class="el" href="operator__node_8cpp_source.html">operator_node.cpp</a></li>
<li>src/CParserFrontend/<a class="el" href="type__system_8cpp_source.html">type_system.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacec__parser__frontend.html">c_parser_frontend</a></li><li class="navelem"><a class="el" href="namespacec__parser__frontend_1_1type__system.html">type_system</a></li><li class="navelem"><a class="el" href="classc__parser__frontend_1_1type__system_1_1FunctionType.html">FunctionType</a></li>
    <li class="footer">制作者
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
